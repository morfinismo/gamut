'use strict'; //App Maker TextBox widget validator

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var validateTextBox = function validateTextBox(widget) {
  return widget.__gwt_instance.mb === "TextField";
}; //App Maker DateBox widget validator


var validateCheckBox = function validateCheckBox(widget) {
  return widget.__gwt_instance.mb === "CheckBoxComponent";
}; //App Maker Page widget validator


var validatPageWidget = function validatPageWidget(widget) {
  return widget.__gwt_instance.mb === "Panel" && widget.parent === null;
}; //App Maker DateBox widget validator


var validateDateBox = function validateDateBox(widget) {
  return widget.__gwt_instance.mb === "DateTextBox";
}; //div element generator


var newElem = function newElem(elem) {
  return document.createElement(elem);
};

var timeSetter = function timeSetter(textBox, config) {
  //log error if there is no valid textBox
  if (!textBox) {
    console.error("%cGAMUT Time Setter Error: " + "%cEither an input element or a Text Box Widget is required!", "color:red", "color:brown");
    return;
  } //default configuration


  var defaultConfig = {
    leadingZeros: true,
    initialValue: "00:00:00",
    zIndex: 9,
    maxTime: "99:59:59",
    //TODO: enable support to limit the max time,
    valueChange: function valueChange(v) {
      return v;
    }
  }; //main timeSetter object

  var $ts = {
    options: defaultConfig,
    input: textBox,
    isAppMaker: false
  }; //check if it's an App Maker widget and if it is, extract the input element and override the $ts.input value

  if (textBox.__gwt_instance !== undefined && textBox.__gwt_instance !== null && validateTextBox(textBox)) {
    $ts.input = textBox.getElement().children[1];
    $ts.isAppMaker = true;
  } //force the input to be text type


  $ts.input.setAttribute("type", "text"); //modify label position if App Maker widget

  if ($ts.isAppMaker) {
    textBox.getElement().children[0].classList.add("gamut--label-fix");
  } //set options values from config


  if (config !== undefined && config !== null && _typeof(config) === "object") {
    if (config.leadingZeros !== undefined && config.leadingZeros !== null) {
      if (typeof config.leadingZeros === "boolean") {
        $ts.options.leadingZeros = config.leadingZeros;
      }
    }

    if (config.initialValue !== undefined && config.initialValue !== null) {
      if (new RegExp(/\d{1,2}:\d{1,2}:\d{1,2}/).test(config.initialValue)) {
        $ts.options.initialValue = config.initialValue;
      }
    }

    if (config.zIndex !== undefined && config.zIndex !== null) {
      var newZindex = parseInt(config.zIndex);

      if (typeof newZindex === "number") {
        $ts.options.zIndex = newZindex;
      }
    }

    if (config.valueChange !== undefined && config.valueChange !== null) {
      if (typeof config.valueChange === "function") {
        $ts.options.valueChange = config.valueChange;
      }
    }
  } //establish the hour, minute and second values


  $ts.hourValue = parseInt($ts.options.initialValue.split(":")[0]);
  $ts.minuteValue = parseInt($ts.options.initialValue.split(":")[1]);
  $ts.secondValue = parseInt($ts.options.initialValue.split(":")[2]); //set value to the $ts.input

  $ts.setValue = function () {
    var hasChanged = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var hours = $ts.hourValue;
    var minutes = $ts.minuteValue;
    var seconds = $ts.secondValue;

    if ($ts.options.leadingZeros) {
      hours = $ts.hourValue < 10 ? "0" + $ts.hourValue : $ts.hourValue;
      minutes = $ts.minuteValue < 10 ? "0" + $ts.minuteValue : $ts.minuteValue;
      seconds = $ts.secondValue < 10 ? "0" + $ts.secondValue : $ts.secondValue;
    }

    var newValue = "".concat(hours, ":").concat(minutes, ":").concat(seconds);
    $ts.input.value = newValue;

    if (hasChanged) {
      $ts.options.valueChange(newValue);
    }
  };

  $ts.setValue(); //sets the default value upon initialization
  //handles the time argument value change when a controller is clicked

  $ts.controllerClick = function (e) {
    var controller = e.target;
    var action = controller.getAttribute("data-action");
    var argumentInput = controller.parentElement.children[0];
    var argumentType = argumentInput.getAttribute("data-timearg");
    var currentValue = parseInt(argumentInput.value);
    var newValue;
    /* when adding, hours can go up with no limit, minutes and seconds can not go beyond 59,
       it they do, the value will reset to 0. When substracting, hours can not go below 0,
       minutes and seconds can not go below 0, if they do, the value will reset to 59
    */

    if (action === "add") {
      if (argumentType === "hrs") {
        newValue = currentValue + 1;
      } else if (argumentType === "mins" || argumentType === "secs") {
        newValue = currentValue === 59 ? 0 : currentValue + 1;
      }
    } else if (action === "substract") {
      if (argumentType === "hrs") {
        newValue = currentValue - 1;
      } else if (argumentType === "mins" || argumentType === "secs") {
        newValue = currentValue === 0 ? 59 : currentValue - 1;
      }
    }

    newValue = newValue < 1 ? 0 : newValue; //set the time arguments values for the instance

    if (argumentType === "hrs") {
      $ts.hourValue = newValue;
    } else if (argumentType === "mins") {
      $ts.minuteValue = newValue;
    } else if (argumentType === "secs") {
      $ts.secondValue = newValue;
    }

    if (newValue < 10) {
      argumentInput.value = $ts.options.leadingZeros ? "0" + newValue : newValue;
    } else {
      argumentInput.value = newValue;
    } //change the value of the $ts.input


    $ts.setValue(true);
  }; //handles the time parameter value change when manually edited


  $ts.paramChange = function (e) {
    var inputRef = e.target;
    var argumentType = inputRef.getAttribute("data-timearg");
    var currentValue = parseInt(inputRef.value);
    /* hours can go up with no limit, minutes and seconds can not go beyond 59,
        it they do, the value will reset to 0. hours, minutes and seconds can not go below 0.
        if minutes or seconds go below 0, the value will reset to 59
    */

    var newValue;

    if (argumentType === "hrs") {
      newValue = currentValue < 1 ? 0 : currentValue;
      $ts.hourValue = newValue;
    } else if (argumentType === "mins") {
      newValue = currentValue > 59 ? 0 : currentValue < 0 ? 59 : currentValue;
      $ts.minuteValue = newValue;
    } else if (argumentType === "secs") {
      newValue = currentValue > 59 ? 0 : currentValue < 0 ? 59 : currentValue;
      $ts.secondValue = newValue;
    }

    if ($ts.options.leadingZeros && newValue < 10) {
      newValue = "0" + newValue;
    }

    inputRef.value = newValue; //change the value of the $ts.input

    $ts.setValue(true);
  }; //create the timeSetter widget


  var widget = newElem("div"); //open the timeSetter widget

  $ts.open = function (top, left, height, width) {
    //style the widget             
    widget.innerHTML = "";
    widget.style.width = width + "px";
    widget.style.top = top + height + 2 + "px";
    widget.style.left = left + "px";
    widget.style.zIndex = $ts.options.zIndex;
    widget.classList.add("gamut__timeSetter"); //create the widget body

    var body = newElem("div");
    body.classList.add("gamut__timeSetter__body");
    body.style.flexDirection = width < 175 ? "column" : "row"; //create the time parameter boxes

    var timeParams = ["Hrs", "Mins", "Secs"];
    timeParams.forEach(function (timeParam) {
      //create the param box
      var paramBox = newElem("div");
      paramBox.classList.add("gamut__timeSetter__paramBox");
      paramBox.style.width = width < 175 ? "100%" : "33.3%"; //create param label

      var paramLabel = newElem("span");
      paramLabel.classList.add("gamut__timeSetter__paramLabel");
      paramLabel.style.textAlign = width < 175 || width > 224 ? "center" : "left";
      var paramLabelText = document.createTextNode(timeParam);
      paramLabel.appendChild(paramLabelText); //append the param label to param box

      paramBox.appendChild(paramLabel); //create the wrapper for the param input

      var paramInputWrapper = newElem("div");
      paramInputWrapper.classList.add("gamut__timeSetter__paramInputWrapper"); //create the param input

      var parameterInput = newElem("input");
      parameterInput.classList.add("gamut__timeSetter__paramInputWrapper__input");
      parameterInput.style.textAlign = width < 175 || width > 224 ? "center" : "left";
      parameterInput.style.paddingRight = width < 175 || width > 224 ? "15px" : "0px";
      parameterInput.addEventListener("change", $ts.paramChange);
      parameterInput.addEventListener("focus", function (e) {
        parameterInput.select();
      });
      parameterInput.setAttribute("type", "text");

      switch (timeParam) {
        case "Hrs":
          parameterInput.setAttribute("value", $ts.options.leadingZeros && $ts.hourValue < 10 ? "0".concat($ts.hourValue) : $ts.hourValue);
          parameterInput.setAttribute("data-timearg", "hrs");
          break;

        case "Mins":
          parameterInput.setAttribute("value", $ts.options.leadingZeros && $ts.minuteValue < 10 ? "0".concat($ts.minuteValue) : $ts.minuteValue);
          parameterInput.setAttribute("data-timearg", "mins");
          break;

        default:
          parameterInput.setAttribute("value", $ts.options.leadingZeros && $ts.secondValue < 10 ? "0".concat($ts.secondValue) : $ts.secondValue);
          parameterInput.setAttribute("data-timearg", "secs");
      } //append the param input to the wrapper of the param input


      paramInputWrapper.appendChild(parameterInput); //create the plus controller

      var paramPlusButton = newElem("span");
      paramPlusButton.classList.add("gamut__timeSetter__paramInputWrapper__controller--plus");
      paramPlusButton.setAttribute("data-action", "add");
      var paramPlusButtonText = document.createTextNode("❮");
      paramPlusButton.style.top = $ts.isAppMaker ? "0px" : "-2px";
      paramPlusButton.addEventListener("click", $ts.controllerClick);
      paramPlusButton.appendChild(paramPlusButtonText); //append the controller plus to the wrapper of the param input

      paramInputWrapper.appendChild(paramPlusButton); //create the minus controller

      var paramMinusButton = newElem("span");
      paramMinusButton.classList.add("gamut__timeSetter__paramInputWrapper__controller--minus");
      paramMinusButton.setAttribute("data-action", "substract");
      var paramMinusButtonText = document.createTextNode("❯");
      paramMinusButton.style.bottom = $ts.isAppMaker ? "0px" : "-2px";
      paramMinusButton.appendChild(paramMinusButtonText);
      paramMinusButton.addEventListener("click", $ts.controllerClick); //append the minus controller to the wrapper of the param input

      paramInputWrapper.appendChild(paramMinusButton); //append param input wrapper to the param box

      paramBox.appendChild(paramInputWrapper); //append the param box to the body

      body.appendChild(paramBox);
    }); //append boxes wrapper to widget

    widget.appendChild(body); //done button

    var doneButton = newElem("div");
    doneButton.classList.add("gamut__timeSetter__doneButton");
    var doneButtonText = document.createTextNode("DONE");
    doneButton.appendChild(doneButtonText);
    doneButton.addEventListener("click", $ts.close);
    widget.appendChild(doneButton); //insert widget to DOM

    $ts.input.parentNode.appendChild(widget);
    window.addEventListener("click", $ts.close); //attach close to the window click
  }; //close the widget


  $ts.close = function (e) {
    /* If the widget is being rendered in App Maker, then we need to check that the element matches
       the parent element of the input, which is the TextBox widget inside appmaker. If it is not 
       rendered in App Maker, we just need to check it matches the input element.
    */
    var proceedToClose = $ts.isAppMaker ? e.target !== $ts.input.parentElement : e.target !== $ts.input;

    if (proceedToClose) {
      $ts.input.parentNode.removeChild(widget);
      window.removeEventListener("click", $ts.close); //remove close from the window click

      gamut.activeTimeSetter = null;
    }
  }; //prevent widget close


  $ts.preventClose = function (e) {
    e.stopPropagation();
    return false;
  }; //attach prevent close to widget and in case is App Maker, input parent also


  widget.addEventListener("click", $ts.preventClose);

  if ($ts.isAppMaker) {
    $ts.input.parentElement.addEventListener("click", $ts.preventClose);
  } //add focus event to $ts.input


  $ts.focus = function (e) {
    //close any open instance if any
    var isOpened = gamut.activeTimeSetter ? true : false;

    if (isOpened) {
      gamut.activeTimeSetter.close(e);
    } //open a new instance


    var rect = $ts.isAppMaker ? e.target.parentElement.getBoundingClientRect() : $ts.input.getBoundingClientRect();
    $ts.open(rect.top, rect.left, rect.height, rect.width); //save opened instance as active instance

    gamut.activeTimeSetter = $ts;
    $ts.input.blur();
  }; //add the open widget method upon focus


  $ts.input.addEventListener("focus", $ts.focus);
  $ts.input.blur();
  return $ts;
};

var formatTextBox = function formatTextBox(textBox, config) {
  //validate is a TextBox widget
  var isTextBox = validateTextBox(textBox); //proceed if it is a TextBox widget

  if (isTextBox) {
    //supported input types
    var validTypes = ["number", "password", "text"]; //supported options

    var options = {
      type: "text",
      readonly: false,
      min: 0,
      // number type
      max: 999999999,
      // number type
      step: 1,
      // number type
      initialValue: null
    }; //set options values from config

    if (config !== undefined && config !== null && _typeof(config) === "object") {
      if (config.type && validTypes.includes(config.type)) {
        options.type = config.type;
      }

      if (config.readonly !== undefined && config.readonly !== null && typeof config.readonly === "boolean") {
        options.readonly = config.readonly;
      }

      if (config.max !== undefined && config.max !== null && typeof config.max === "number") {
        options.max = config.max;
      }

      if (config.min !== undefined && config.min !== null && typeof config.min === "number") {
        options.min = config.min;
      }

      if (config.step !== undefined && config.step !== null && typeof config.step === "number") {
        options.step = config.step;
      }

      if (config.initialValue !== undefined && config.initialValue !== null) {
        options.initialValue = config.initialValue;
      }
    } //extract the input element


    var elem = textBox.getElement().children[1]; //apply the input type

    elem.setAttribute("type", options.type); //apply readonly if applicable

    if (options.readonly) {
      elem.setAttribute("readonly", "");
    } //modify label position of the TextBox widget


    textBox.getElement().children[0].classList.add("gamut--label-fix"); //apply number attributes if needed

    if (options.type === "number") {
      elem.classList.add("gamut--numberInput");
      elem.setAttribute("max", options.max);
      elem.setAttribute("min", options.min);
      elem.setAttribute("step", options.step);
      elem.value = typeof options.initialValue === "number" ? options.initialValue : options.min;
    }
  }
};

var formatSwitch = function formatSwitch(appmakerWidget, config) {
  var global = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var rootWidgets = arguments.length > 3 ? arguments[3] : undefined;
  //supported options for config object
  var options = {
    checked: !config ? null : config.checked,
    checkedBtn: !config ? null : config.checkedBtn,
    unchecked: !config ? null : config.unchecked,
    uncheckedBtn: !config ? null : config.uncheckedBtn
  };

  var applyPreset = function applyPreset(root, preset) {
    var isGlobal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    var appSwitches = _toConsumableArray(root.querySelectorAll("span")).filter(function (item) {
      return item.classList.toString().indexOf("app-Checkbox--Switch") > -1;
    });

    appSwitches.forEach(function (appSwitch) {
      var classList = _toConsumableArray(appSwitch.classList);

      if (!classList.includes(preset)) {
        if (isGlobal) {
          if (classList.toString().indexOf("gamutSwitch--") === -1 && classList.toString().indexOf("gmt-") === -1) {
            appSwitch.classList.add(preset);
            appSwitch.classList.add("gamutGlobal");
          }
        } else {
          if (classList.includes("gamutGlobal") || classList.toString().indexOf("gamutSwitch--") === -1) {
            var existingGamutClass = "none";

            for (var i = 0; i < classList.length; i++) {
              if (classList[i].indexOf("gamutSwitch--") > -1) {
                existingGamutClass = classList[i];
                break;
              }
            }

            if (classList.toString().indexOf("gmt-") === -1) {
              appSwitch.classList.remove(existingGamutClass);
              appSwitch.classList.remove("gamutGlobal");
              appSwitch.classList.add(preset);
              appSwitch.classList.add("gamutSwitch");
            }
          }
        }
      }
    });
  }; //apply global style


  if (global) {
    if (typeof config === "string") {
      //set preset colors
      var preset = config;
      rootWidgets.forEach(function (page) {
        var root = page.root.getElement();
        var observer = new MutationObserver(function () {
          applyPreset(root, preset);
        });
        observer.observe(root, {
          subtree: true,
          childList: true
        });
        applyPreset(root, preset);
        var observerName = "".concat(page.name, "-switch-observer");
        window.gamut.observers[observerName] = observer;
      });
    } else {
      //set config colors
      if (options.unchecked) {
        document.documentElement.style.setProperty("--unchecked", options.unchecked);
      }

      if (options.uncheckedBtn) {
        document.documentElement.style.setProperty("--uncheckedButton", options.uncheckedBtn);
      }

      if (options.checked) {
        document.documentElement.style.setProperty("--checked", options.checked);
      }

      if (options.checkedBtn) {
        document.documentElement.style.setProperty("--checkedButton", options.checkedBtn);
      }
    }
  } else {
    //validate is it is an appamker page
    var isPage = validatPageWidget(appmakerWidget); //apply style to all switches in the appmaker page

    if (isPage) {
      //get current observer in case global is also being applied
      var observerName = "".concat(appmakerWidget.name, "-switch-observer");
      var currentObserver = window.gamut.observers[observerName]; //disconnect global observer if any

      if (currentObserver) {
        currentObserver.disconnect();
      } //apply page level styles depending on the congif type(string or object)


      var page = appmakerWidget;

      if (typeof config === "string") {
        //set preset colors
        var _preset = config;
        var root = page.root.getElement();
        var observer = new MutationObserver(function () {
          applyPreset(root, _preset, false);
        });
        observer.observe(root, {
          subtree: true,
          childList: true
        });
        applyPreset(root, _preset, false);
        window.gamut.observers[observerName] = observer;
      } else {
        //set config colors
        if (options.unchecked) {
          document.documentElement.style.setProperty("--unchecked", options.unchecked);
        }

        if (options.uncheckedBtn) {
          document.documentElement.style.setProperty("--uncheckedButton", options.uncheckedBtn);
        }

        if (options.checked) {
          document.documentElement.style.setProperty("--checked", options.checked);
        }

        if (options.checkedBtn) {
          document.documentElement.style.setProperty("--checkedButton", options.checkedBtn);
        }
      }
    } else {
      //validate if it is a Checkbox widget
      var isCheckBox = validateCheckBox(appmakerWidget); //apply style to checkbox switch if it is a checkbox

      if (isCheckBox) {
        //get html element from widget
        var elem = appmakerWidget.getElement(); //remove any gamut style

        var classList = _toConsumableArray(elem.classList);

        classList.forEach(function (className) {
          if (className.includes("gamutSwitch")) {
            elem.classList.remove(className);
          }
        }); //check if it has already been styled

        var isStyled = classList.toString().indexOf("gmt-") > -1; //apply style if it hasnt been applied before

        if (!isStyled) {
          //generate a unique class name
          var className = "gmt-".concat(Math.random().toString().slice(2));
          elem.classList.add(className); //get the colors from config

          var unchecked = options.unchecked || rgba(0, 0, 0, 0.5);
          var uncheckedBtn = options.uncheckedBtn || rgb(255, 255, 255);
          var checked = options.checked || rgb(66, 133, 244);
          var checkedBtn = options.checkedBtn || rgb(66, 133, 244); //construct style elem

          var styleElem = newElem("style");
          var styleData = "\n                    .".concat(className, " > .app-Checkbox-Input {\n                        background-color: ").concat(unchecked, ";\n                    }\n                    \n                    .").concat(className, " > .app-Checkbox-Label:after {\n                        background-color: ").concat(uncheckedBtn, ";\n                    }\n                    \n                    .").concat(className, " > .app-Checkbox-Input:checked {\n                        background-color: ").concat(checked, ";\n                    }\n                    \n                    .").concat(className, " > .app-Checkbox-Input:checked + .app-Checkbox-Label:after {\n                        background-color: ").concat(checkedBtn, ";\n                    }                  \n                    "); //append style data to style elem

          styleElem.innerHTML = styleData; //append style elem to document body

          document.body.appendChild(styleElem);
        }
      }
    }
  }
};

var timePicker = function timePicker(dateBox, config) {
  //log error if there is no valid dateBox
  if (!dateBox) {
    console.error("%cGAMUT Time Picker Error: " + "%cEither an input element or a Date Box Widget is required!", "color:red", "color:brown");
    return;
  } //default configuration


  var defaultConfig = {
    initialValue: "08:00",
    zIndex: 9,
    valueChange: function valueChange(v) {
      return v;
    }
  }; //main timePicker object

  var $tp = {
    options: defaultConfig,
    input: dateBox,
    isAppMaker: false
  }; //check if it's an App Maker widget and if it is, extract the input element and override the $tp.input value

  if (dateBox.__gwt_instance !== undefined && dateBox.__gwt_instance !== null && validateDateBox(dateBox)) {
    $tp.input = dateBox.getElement().children[1];
    $tp.isAppMaker = true;
  } //force the input to be text type


  $tp.input.setAttribute("type", "text"); //modify label position if App Maker widget

  if ($tp.isAppMaker) {
    dateBox.getElement().children[0].classList.add("gamut--label-fix");
  } //set options values from config


  if (config !== undefined && config !== null && _typeof(config) === "object") {
    if (config.initialValue !== undefined && config.initialValue !== null) {
      if (new RegExp(/\d{1,2}:\d{1,2}:\d{1,2}/).test(config.initialValue)) {
        $tp.options.initialValue = config.initialValue;
      }
    }

    if (config.zIndex !== undefined && config.zIndex !== null) {
      var newZindex = parseInt(config.zIndex);

      if (typeof newZindex === "number") {
        $tp.options.zIndex = newZindex;
      }
    }

    if (config.valueChange !== undefined && config.valueChange !== null) {
      if (typeof config.valueChange === "function") {
        $tp.options.valueChange = config.valueChange;
      }
    }
  } //establish the hour, minute and meridiam values


  var hourValue = parseInt($tp.options.initialValue.split(":")[0]);
  $tp.hourValue = hourValue > 23 || hourValue === 0 ? 12 : hourValue > 12 ? hourValue - 12 : hourValue;
  $tp.minuteValue = parseInt($tp.options.initialValue.split(":")[1]);
  $tp.meridiamValue = hourValue > 23 ? "am" : hourValue > 12 ? "pm" : "am"; //set value to the $tp.input

  $tp.setValue = function () {
    var hasChanged = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var hours = $tp.hourValue;
    var minutes = $tp.minuteValue;
    var meridiam = $tp.meridiamValue;
    hours = $tp.hourValue < 10 ? "0" + $tp.hourValue : $tp.hourValue;
    minutes = $tp.minuteValue < 10 ? "0" + $tp.minuteValue : $tp.minuteValue;
    var newValue = "".concat(hours, ":").concat(minutes, " ").concat(meridiam);
    $tp.input.value = newValue;

    if (hasChanged) {
      $tp.options.valueChange(newValue);
    }
  };

  $tp.setValue(); //setp the default value upon initialization
  //create the timePicker widget

  var widget = newElem("div"); //open the timePicker widget

  $tp.open = function (top, left, height, width) {
    var activateRotate = function activateRotate(e) {
      var elem = e.target;
      rotateHand(elem);
    };

    var rotateHand = function rotateHand(elem) {
      var rotateVal = elem.style.transform;
      console.dir(elem);
    };

    var getMinHandInitialRotate = function getMinHandInitialRotate(minValue) {
      var degrees = 360 / 60;
      var initalValue = minValue * degrees;
      return initalValue;
    };

    var getHourHandInitialRotate = function getHourHandInitialRotate(hourValue) {
      var degrees = 360 / 12;
      var initialValue = hourValue * degrees;
      return initialValue;
    }; //style the widget             


    widget.innerHTML = ""; //widget.style.width = width + "px";

    widget.style.top = top + height + 2 + "px";
    widget.style.left = left + "px";
    widget.style.zIndex = $tp.options.zIndex;
    widget.classList.add("gamut__timePicker"); //create the widget time display

    var timeDisplay = newElem("div");
    timeDisplay.classList.add("gamut__timePicker__time"); //append the time display to the widget

    widget.appendChild(timeDisplay); //create the meridiam selector

    var meridiamSelector = newElem("div");
    meridiamSelector.classList.add("gamut__timePicker__meridiamSelector");
    var amSelector = newElem("div");
    amSelector.innerHTML = "AM";
    amSelector.classList.add("gamut__timePicker__meridiamSelector--am");
    meridiamSelector.appendChild(amSelector);
    var pmSelector = newElem("div");
    pmSelector.innerHTML = "PM";
    pmSelector.classList.add("gamut__timePicker__meridiamSelector--pm");
    meridiamSelector.appendChild(pmSelector); //append the meridiam selector to the widget

    widget.appendChild(meridiamSelector); //create the analog clock

    var clockWrapper = newElem("div");
    clockWrapper.classList.add("gamut__timePicker__clockWrapper");
    var clock = newElem("div");
    clock.classList.add("gamut__timePicker__clock");
    var minutePointers = 60;
    var rotateDegree = 360 / minutePointers;
    var clockSize = 202;
    var rotateValue = 90;

    for (var i = 0; i < minutePointers; i++) {
      var pointer = newElem("div");
      var angle = i * (Math.PI / (minutePointers / 2));

      var _left = clockSize / 2 + clockSize / 2 * Math.cos(angle);

      var leftPercent = _left * 100 / clockSize;

      var _top = clockSize / 2 + clockSize / 2 * Math.sin(angle);

      var topPercent = _top * 100 / clockSize;

      if (i % 5 === 0) {
        pointer.classList.add("gamut__timePicker__clock--hrPointer");
      } else {
        pointer.classList.add("gamut__timePicker__clock--minPointer");
      }

      pointer.style.transform = "rotate(".concat(rotateValue, "deg)");
      pointer.style.left = "".concat(leftPercent, "%");
      pointer.style.top = "".concat(topPercent, "%");
      clock.appendChild(pointer);
      rotateValue += rotateDegree;
    }

    clockWrapper.appendChild(clock);
    var clockLabels = newElem("div");
    clockLabels.classList.add("gamut__timePicker__labels");
    var totalLabels = 12;
    var rotateDegree = 360 / totalLabels;
    var circleSize = 160;
    var hourValue = 3;

    for (var i = 0; i < totalLabels; i++) {
      var label = newElem("span");
      label.innerHTML = hourValue;

      var _angle = i * (Math.PI / (totalLabels / 2));

      var _left2 = circleSize / 2 + circleSize / 2 * Math.cos(_angle);

      var _leftPercent = _left2 * 100 / circleSize;

      var _top2 = circleSize / 2 + circleSize / 2 * Math.sin(_angle);

      var _topPercent = _top2 * 100 / circleSize;

      label.classList.add("gamut__timePicker__labels--hourLabel");
      label.style.left = "".concat(_leftPercent, "%");
      label.style.top = "".concat(_topPercent, "%");
      clockLabels.appendChild(label);
      hourValue++;

      if (hourValue > 12) {
        hourValue = 1;
      }
    }

    clockWrapper.appendChild(clockLabels);
    var minHand = newElem("div");
    minHand.classList.add("gamut__timePicker__minHand");
    minHand.style.transform = "rotate(".concat(getMinHandInitialRotate($tp.minuteValue), "deg)");
    minHand.addEventListener("mousedown", activateRotate);
    clockWrapper.appendChild(minHand);
    var hrHand = newElem("div");
    hrHand.classList.add("gamut__timePicker__hrHand");
    hrHand.style.transform = "rotate(".concat(getHourHandInitialRotate($tp.hourValue), "deg)");
    clockWrapper.appendChild(hrHand); //append clockWrapper to widget

    widget.appendChild(clockWrapper); //done button

    var doneButton = newElem("div");
    doneButton.classList.add("gamut__timePicker__done");
    var doneButtonText = document.createTextNode("DONE");
    doneButton.appendChild(doneButtonText);
    doneButton.addEventListener("click", $tp.close);
    widget.appendChild(doneButton); //insert widget to DOM

    $tp.input.parentNode.appendChild(widget);
    window.addEventListener("click", $tp.close); //attach close to the window click
  }; //close the widget


  $tp.close = function (e) {
    /* If the widget is being rendered in App Maker, then we need to check that the element matches
        the parent element of the input, which is the dateBox widget inside appmaker. If it is not 
        rendered in App Maker, we just need to check it matches the input element.
    */
    var proceedToClose = $tp.isAppMaker ? e.target !== $tp.input.parentElement : e.target !== $tp.input;

    if (proceedToClose) {
      $tp.input.parentNode.removeChild(widget);
      window.removeEventListener("click", $tp.close); //remove close from the window click

      gamut.activeTimeSetter = null;
    }
  }; //prevent widget close


  $tp.preventClose = function (e) {
    e.stopPropagation();
    return false;
  }; //attach prevent close to widget and in case is App Maker, input parent also


  widget.addEventListener("click", $tp.preventClose);

  if ($tp.isAppMaker) {
    $tp.input.parentElement.addEventListener("click", $tp.preventClose);
  } //add focus event to $tp.input


  $tp.focus = function (e) {
    console.log("here"); //close any open instance if any

    var isOpened = gamut.activeTimePicker ? true : false;

    if (isOpened) {
      gamut.activeTimePicker.close(e);
    } //open a new instance


    var rect = $tp.isAppMaker ? e.target.parentElement.getBoundingClientRect() : $tp.input.getBoundingClientRect();
    $tp.open(rect.top, rect.left, rect.height, rect.width); //save opened instance as active instance

    gamut.activeTimePicker = $tp;
    $tp.input.blur();
  }; //add the open widget method upon focus


  $tp.input.addEventListener("focus", $tp.focus);
  $tp.input.blur();
  return $tp;
};

(function (window) {
  var $gmt = {
    /* Initiate Library */
    init: function init(app, config) {
      /* Library Properties */
      this.observers = {}; //this property helps to keep track of certain elements that are being observed for changes on some utilities

      /* Add general utilities */

      this.activeTimeSetter = null; //helper to keep track of the current open instance of timeSetter

      this.timeSetter = timeSetter;
      this.activeTimePicker = null; //helper to keep track of the current open instance of timePicker

      this.timePicker = timePicker;
      /* Init Config */

      if (!app || !app.appKey) {
        console.warn("%cGAMUT Init Warning: %c\"app\" parameter is required for Google App Maker. Some features may not work!", "color: red", "color:brown");
      } else {
        /* Add Google App Maker specfic utilities */
        this.formatTextBox = formatTextBox;
        this.formatSwitch = formatSwitch;
        /* formatSwitches init config */

        var pages = app.pages._values;
        var popups = app.popups._values;
        var pageFragments = app.pageFragments._values;
        var rootWidgets = [].concat(_toConsumableArray(pages), _toConsumableArray(popups), _toConsumableArray(pageFragments));
        var gamutSwitches = [];
        rootWidgets.forEach(function (rootWidget) {
          var root = rootWidget.root.getElement();
          gamutSwitches = [].concat(_toConsumableArray(gamutSwitches), _toConsumableArray(root.querySelectorAll("span"))).filter(function (item) {
            return item.classList.toString().indexOf("gamutSwitch--") > -1;
          });
        });
        gamutSwitches.forEach(function (gamutSwitch) {
          gamutSwitch.classList.add("gamutSwitch");
        });

        if (config !== undefined && config !== null && _typeof(config) === "object") {
          if (config.defaultSwitch !== undefined && config.defaultSwitch !== null) {
            var defaultSwitch = config.defaultSwitch;
            formatSwitch(null, config.defaultSwitch, true, rootWidgets);
          }
        }
      }
    }
  };
  window.gamut = $gmt;
})(window);